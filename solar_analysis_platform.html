<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Solar Energy Analysis Platform</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    
    <!-- Leaflet Draw CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
    
    <!-- Chart.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.min.js"></script>
    
    <!-- Leaflet JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    
    <!-- Leaflet Draw -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    
    <!-- TensorFlow.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.10.0/tf.min.js"></script>
    
    <!-- Papa Parse for CSV -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    
    <!-- Turf.js for GIS operations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .header {
            background: rgba(255, 255, 255, 0.98);
            padding: 15px 20px;
            box-shadow: 0 2px 20px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 1000;
        }
        
        .header-content {
            max-width: 1600px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .logo h1 {
            font-size: 1.8em;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .status-bar {
            display: flex;
            gap: 20px;
            align-items: center;
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 15px;
            background: #f0f0f0;
            border-radius: 20px;
            font-size: 0.9em;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4caf50;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .main-container {
            display: flex;
            height: calc(100vh - 70px);
        }
        
        .sidebar {
            width: 400px;
            background: rgba(255, 255, 255, 0.95);
            overflow-y: auto;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
        }
        
        .tab-nav {
            display: flex;
            background: #f5f5f5;
            border-bottom: 2px solid #ddd;
        }
        
        .tab-btn {
            flex: 1;
            padding: 15px;
            border: none;
            background: none;
            cursor: pointer;
            font-weight: 600;
            color: #666;
            transition: all 0.3s ease;
        }
        
        .tab-btn.active {
            background: white;
            color: #1e3c72;
            border-bottom: 2px solid #1e3c72;
            margin-bottom: -2px;
        }
        
        .tab-content {
            display: none;
            padding: 20px;
            animation: fadeIn 0.3s ease;
        }
        
        .tab-content.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .map-container {
            flex: 1;
            position: relative;
        }
        
        #map {
            width: 100%;
            height: 100%;
        }
        
        .map-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 500;
            max-width: 250px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .layer-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 5px 0;
        }
        
        .layer-toggle input {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .data-panel {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        
        .data-panel h3 {
            color: #1e3c72;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .input-group {
            margin-bottom: 15px;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
        }
        
        .input-group input, 
        .input-group select, 
        .input-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }
        
        .input-group input:focus, 
        .input-group select:focus {
            outline: none;
            border-color: #1e3c72;
        }
        
        .btn {
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            margin: 5px;
            display: inline-block;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(30, 60, 114, 0.3);
        }
        
        .btn-secondary {
            background: #f0f0f0;
            color: #333;
        }
        
        .btn-secondary:hover {
            background: #e0e0e0;
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .results-panel {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }
        
        .metric-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .metric-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        
        .metric-label {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 5px;
        }
        
        .metric-value {
            font-size: 1.4em;
            font-weight: bold;
            color: #1e3c72;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #8bc34a);
            transition: width 0.5s ease;
        }
        
        .api-monitor {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-family: monospace;
            font-size: 12px;
            max-width: 300px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
        }
        
        .api-log {
            margin: 5px 0;
            padding: 5px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }
        
        .loading-spinner {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #1e3c72;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .chart-container {
            height: 250px;
            margin-top: 15px;
        }
        
        .file-upload {
            border: 2px dashed #ddd;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .file-upload:hover {
            border-color: #1e3c72;
            background: #f8f9fa;
        }
        
        .file-upload.dragover {
            border-color: #4caf50;
            background: #e8f5e9;
        }
        
        .tooltip-custom {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
            z-index: 10000;
            max-width: 200px;
        }
        
        .notification {
            position: fixed;
            top: 80px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            z-index: 10000;
            min-width: 300px;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }
        
        .notification.show {
            transform: translateX(0);
        }
        
        .notification.success {
            background: #4caf50;
        }
        
        .notification.error {
            background: #f44336;
        }
        
        .notification.warning {
            background: #ff9800;
        }
        
        .shadow-analysis {
            position: absolute;
            top: 120px;
            left: 20px;
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 500;
            display: none;
        }
        
        @media (max-width: 768px) {
            .sidebar {
                width: 100%;
                height: 50vh;
            }
            
            .main-container {
                flex-direction: column;
            }
            
            .map-controls {
                right: 10px;
                max-width: 200px;
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <div class="logo">
                <h1>☀️ Solar Energy Analysis Platform</h1>
                <span style="color: #666;">Advanced GIS & AI Integration</span>
            </div>
            <div class="status-bar">
                <div class="status-indicator">
                    <div class="status-dot" id="nrelStatus"></div>
                    <span>NREL API</span>
                </div>
                <div class="status-indicator">
                    <div class="status-dot" style="background: #ff9800;" id="nasaStatus"></div>
                    <span>NASA POWER</span>
                </div>
                <div class="status-indicator">
                    <div class="status-dot" style="background: #2196f3;" id="modelStatus"></div>
                    <span>AI Model</span>
                </div>
            </div>
        </div>
    </div>
    
    <div class="main-container">
        <div class="sidebar">
            <div class="tab-nav">
                <button class="tab-btn active" onclick="switchTab('data')">📊 Data</button>
                <button class="tab-btn" onclick="switchTab('analysis')">🔬 Analysis</button>
                <button class="tab-btn" onclick="switchTab('model')">🤖 AI Model</button>
                <button class="tab-btn" onclick="switchTab('api')">🔌 API</button>
            </div>
            
            <!-- Data Sources Tab -->
            <div id="data-tab" class="tab-content active">
                <div class="data-panel">
                    <h3>🌍 NREL Solar Database</h3>
                    <div class="input-group">
                        <label>API Key</label>
                        <input type="password" id="nrelApiKey" placeholder="Enter NREL API Key" value="DEMO_KEY">
                    </div>
                    <div class="input-group">
                        <label>Location</label>
                        <input type="text" id="location" placeholder="City, State" value="Denver, CO">
                    </div>
                    <button class="btn" onclick="fetchNRELData()">Fetch Solar Data</button>
                    <button class="btn btn-secondary" onclick="testNRELConnection()">Test Connection</button>
                    
                    <div class="progress-bar" style="margin-top: 15px;">
                        <div class="progress-fill" id="nrelProgress" style="width: 0%;"></div>
                    </div>
                </div>
                
                <div class="data-panel">
                    <h3>🛰️ NASA POWER Data</h3>
                    <div class="input-group">
                        <label>Latitude</label>
                        <input type="number" id="nasaLat" placeholder="Latitude" value="39.7392" step="0.0001">
                    </div>
                    <div class="input-group">
                        <label>Longitude</label>
                        <input type="number" id="nasaLon" placeholder="Longitude" value="-104.9903" step="0.0001">
                    </div>
                    <div class="input-group">
                        <label>Date Range</label>
                        <select id="dateRange">
                            <option value="daily">Daily</option>
                            <option value="monthly">Monthly</option>
                            <option value="annual">Annual</option>
                        </select>
                    </div>
                    <button class="btn" onclick="fetchNASAData()">Fetch NASA Data</button>
                </div>
                
                <div class="data-panel">
                    <h3>📁 Building Footprints</h3>
                    <div class="file-upload" id="buildingUpload" onclick="document.getElementById('fileInput').click()" ondrop="handleDrop(event)" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                        <p>📤 Drag & Drop GeoJSON/Shapefile</p>
                        <p style="font-size: 0.9em; color: #666; margin-top: 10px;">or click to browse</p>
                        <input type="file" id="fileInput" accept=".geojson,.json,.shp" style="display: none;" onchange="handleFileSelect(event)">
                    </div>
                </div>
                
                <div class="data-panel">
                    <h3>🏔️ Elevation Data</h3>
                    <div class="input-group">
                        <label>Data Source</label>
                        <select id="demSource">
                            <option value="mapbox">Mapbox Terrain</option>
                            <option value="usgs">USGS 3DEP</option>
                            <option value="synthetic">Synthetic DEM</option>
                        </select>
                    </div>
                    <button class="btn" onclick="loadDEMData()">Load Elevation</button>
                </div>
            </div>
            
            <!-- Analysis Tab -->
            <div id="analysis-tab" class="tab-content">
                <div class="data-panel">
                    <h3>📐 Solar Parameters</h3>
                    <div class="input-group">
                        <label>Panel Type</label>
                        <select id="panelType">
                            <option value="mono">Monocrystalline (20%)</option>
                            <option value="poly">Polycrystalline (17%)</option>
                            <option value="thin">Thin Film (11%)</option>
                            <option value="bifacial">Bifacial (22%)</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label>Tilt Angle (degrees)</label>
                        <input type="number" id="tiltAngle" value="35" min="0" max="90">
                    </div>
                    <div class="input-group">
                        <label>Azimuth (degrees)</label>
                        <input type="number" id="azimuth" value="180" min="0" max="360">
                    </div>
                    <div class="input-group">
                        <label>System Losses (%)</label>
                        <input type="number" id="systemLosses" value="14" min="0" max="100">
                    </div>
                    <button class="btn" onclick="runAdvancedAnalysis()">Run Analysis</button>
                    <button class="btn btn-secondary" onclick="optimizeParameters()">Auto Optimize</button>
                </div>
                
                <div class="results-panel">
                    <h3>📊 Analysis Results</h3>
                    <div class="metric-grid">
                        <div class="metric-item">
                            <div class="metric-label">Annual Production</div>
                            <div class="metric-value" id="annualProduction">0 MWh</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-label">Capacity Factor</div>
                            <div class="metric-value" id="capacityFactor">0%</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-label">LCOE</div>
                            <div class="metric-value" id="lcoe">$0/kWh</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-label">Payback Period</div>
                            <div class="metric-value" id="payback">0 years</div>
                        </div>
                    </div>
                    <div class="chart-container">
                        <canvas id="productionChart"></canvas>
                    </div>
                </div>
            </div>
            
            <!-- AI Model Tab -->
            <div id="model-tab" class="tab-content">
                <div class="data-panel">
                    <h3>🧠 Model Training</h3>
                    <div class="input-group">
                        <label>Training Data</label>
                        <select id="trainingData">
                            <option value="historical">Historical Installations (50k records)</option>
                            <option value="synthetic">Synthetic Data (100k records)</option>
                            <option value="combined">Combined Dataset (150k records)</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label>Model Architecture</label>
                        <select id="modelArch">
                            <option value="dnn">Deep Neural Network</option>
                            <option value="random_forest">Random Forest</option>
                            <option value="xgboost">XGBoost</option>
                            <option value="ensemble">Ensemble Model</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label>Features</label>
                        <textarea id="features" rows="4">latitude, longitude, roof_area, azimuth, tilt, shading_factor, panel_efficiency, temperature, dni, ghi, dhi</textarea>
                    </div>
                    <button class="btn" onclick="trainModel()" id="trainBtn">Start Training</button>
                    <button class="btn btn-secondary" onclick="loadPretrainedModel()">Load Pretrained</button>
                </div>
                
                <div class="data-panel">
                    <h3>📈 Training Progress</h3>
                    <div class="metric-grid">
                        <div class="metric-item">
                            <div class="metric-label">Epoch</div>
                            <div class="metric-value" id="currentEpoch">0/100</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-label">Loss</div>
                            <div class="metric-value" id="trainingLoss">-</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-label">Accuracy</div>
                            <div class="metric-value" id="modelAccuracy">-</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-label">Val. R²</div>
                            <div class="metric-value" id="valR2">-</div>
                        </div>
                    </div>
                    <div class="chart-container">
                        <canvas id="lossChart"></canvas>
                    </div>
                </div>
                
                <div class="data-panel">
                    <h3>🔮 Model Prediction</h3>
                    <div class="input-group">
                        <label>Test Input (JSON)</label>
                        <textarea id="testInput" rows="6">{
  "latitude": 39.7392,
  "longitude": -104.9903,
  "roof_area": 200,
  "azimuth": 180,
  "tilt": 35,
  "panel_efficiency": 0.20
}</textarea>
                    </div>
                    <button class="btn" onclick="makePrediction()">Predict Output</button>
                    <div class="results-panel" style="margin-top: 15px;">
                        <div id="predictionResult">Click "Predict Output" to see results</div>
                    </div>
                </div>
            </div>
            
            <!-- API Tab -->
            <div id="api-tab" class="tab-content">
                <div class="data-panel">
                    <h3>🔌 REST API Endpoints</h3>
                    <div style="background: #f5f5f5; padding: 15px; border-radius: 5px; font-family: monospace; font-size: 0.9em;">
                        <p><strong>Base URL:</strong> https://api.solaranalysis.com/v1</p>
                        <br>
                        <p><strong>GET</strong> /solar/potential</p>
                        <p style="color: #666; margin-left: 20px;">→ Get solar potential for location</p>
                        <br>
                        <p><strong>POST</strong> /analysis/calculate</p>
                        <p style="color: #666; margin-left: 20px;">→ Calculate energy output</p>
                        <br>
                        <p><strong>POST</strong> /model/predict</p>
                        <p style="color: #666; margin-left: 20px;">→ AI model prediction</p>
                        <br>
                        <p><strong>GET</strong> /data/buildings/{id}</p>
                        <p style="color: #666; margin-left: 20px;">→ Get building footprint data</p>
                    </div>
                </div>
                
                <div class="data-panel">
                    <h3>🔐 API Configuration</h3>
                    <div class="input-group">
                        <label>API Key</label>
                        <input type="text" id="apiKey" value="sk-demo-1234567890" readonly>
                        <button class="btn btn-secondary" style="margin-top: 10px;" onclick="generateAPIKey()">Generate New Key</button>
                    </div>
                    <div class="input-group">
                        <label>Rate Limit</label>
                        <select id="rateLimit">
                            <option value="100">100 req/hour</option>
                            <option value="1000">1000 req/hour</option>
                            <option value="10000">10000 req/hour</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label>Webhook URL</label>
                        <input type="url" id="webhookUrl" placeholder="https://your-server.com/webhook">
                    </div>
                    <button class="btn" onclick="saveAPIConfig()">Save Configuration</button>
                </div>
                
                <div class="data-panel">
                    <h3>📡 Test API</h3>
                    <div class="input-group">
                        <label>Endpoint</label>
                        <select id="testEndpoint">
                            <option value="/solar/potential">GET /solar/potential</option>
                            <option value="/analysis/calculate">POST /analysis/calculate</option>
                            <option value="/model/predict">POST /model/predict</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label>Request Body</label>
                        <textarea id="requestBody" rows="6">{
  "latitude": 39.7392,
  "longitude": -104.9903
}</textarea>
                    </div>
                    <button class="btn" onclick="testAPI()">Send Request</button>
                    <div class="data-panel" style="margin-top: 15px; background: #263238; color: #aed581;">
                        <pre id="apiResponse" style="margin: 0; font-size: 0.85em;">Response will appear here...</pre>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="map-container">
            <div id="map"></div>
            <div class="loading-spinner" id="loadingSpinner">
                <div class="spinner"></div>
            </div>
            
            <div class="map-controls">
                <div class="control-group">
                    <label>Map Layers</label>
                    <div class="layer-toggle">
                        <input type="checkbox" id="solarLayer" checked onchange="toggleLayer('solar')">
                        <label for="solarLayer">Solar Irradiance</label>
                    </div>
                    <div class="layer-toggle">
                        <input type="checkbox" id="buildingLayer" onchange="toggleLayer('buildings')">
                        <label for="buildingLayer">Building Footprints</label>
                    </div>
                    <div class="layer-toggle">
                        <input type="checkbox" id="shadowLayer" onchange="toggleLayer('shadows')">
                        <label for="shadowLayer">Shadow Analysis</label>
                    </div>
                    <div class="layer-toggle">
                        <input type="checkbox" id="demLayer" onchange="toggleLayer('dem')">
                        <label for="demLayer">Elevation</label>
                    </div>
                </div>
                
                <div class="control-group">
                    <label>Analysis Tools</label>
                    <button class="btn btn-secondary" onclick="startDrawing()" style="width: 100%; margin: 2px 0;">Draw Area</button>
                    <button class="btn btn-secondary" onclick="measureDistance()" style="width: 100%; margin: 2px 0;">Measure</button>
                    <button class="btn btn-danger" onclick="clearDrawings()" style="width: 100%; margin: 2px 0;">Clear</button>
                </div>
                
                <div class="control-group">
                    <label>Shadow Time</label>
                    <input type="time" id="shadowTime" value="12:00" onchange="updateShadowAnalysis()" style="width: 100%; padding: 5px; border: 1px solid #ddd; border-radius: 3px;">
                </div>
            </div>
        </div>
        
        <div class="shadow-analysis" id="shadowPanel">
            <h4>🌅 Shadow Analysis</h4>
            <div style="margin: 10px 0;">
                <label>Date:</label>
                <input type="date" id="shadowDate" value="2024-06-21" onchange="updateShadowAnalysis()">
            </div>
            <div style="margin: 10px 0;">
                <label>Building Height (m):</label>
                <input type="number" id="buildingHeight" value="10" min="1" max="200" onchange="updateShadowAnalysis()">
            </div>
            <button class="btn btn-secondary" onclick="calculateShadows()">Calculate Shadows</button>
        </div>
    </div>
    
    <div class="api-monitor" id="apiMonitor">
        <div style="color: #4caf50; font-weight: bold; margin-bottom: 10px;">API Monitor</div>
        <div id="apiLogs"></div>
    </div>
    
    <div class="tooltip-custom" id="mapTooltip" style="display: none;"></div>
    
    <script>
        // Global variables
        let map;
        let drawnItems;
        let solarLayer;
        let buildingLayer;
        let shadowLayer;
        let demLayer;
        let model;
        let trainingData = [];
        let apiLogs = [];
        let currentAnalysis = null;
        let productionChart = null;
        let lossChart = null;
        let isTraining = false;
        
        // Initialize application
        document.addEventListener('DOMContentLoaded', function() {
            initMap();
            initCharts();
            loadSampleData();
            updateStatusIndicators();
            logAPI('System initialized', 'success');
        });
        
        // Initialize map
        function initMap() {
            map = L.map('map').setView([39.7392, -104.9903], 12);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors'
            }).addTo(map);
            
            // Initialize drawing tools
            drawnItems = new L.FeatureGroup();
            map.addLayer(drawnItems);
            
            const drawControl = new L.Control.Draw({
                edit: {
                    featureGroup: drawnItems,
                    remove: true
                },
                draw: {
                    polygon: true,
                    rectangle: true,
                    circle: true,
                    marker: true,
                    polyline: true,
                    circlemarker: false
                }
            });
            map.addControl(drawControl);
            
            // Map event listeners
            map.on('draw:created', function(e) {
                const layer = e.layer;
                drawnItems.addLayer(layer);
                
                if (e.layerType === 'polygon' || e.layerType === 'rectangle') {
                    calculateAreaAnalysis(layer);
                }
            });
            
            map.on('click', function(e) {
                const lat = e.latlng.lat;
                const lng = e.latlng.lng;
                updateCoordinateInputs(lat, lng);
                showLocationPopup(e.latlng, lat, lng);
            });
            
            // Initialize sample solar irradiance layer
            initSolarLayer();
        }
        
        // Initialize solar irradiance layer with sample data
        function initSolarLayer() {
            const solarData = generateSampleSolarData();
            solarLayer = L.layerGroup();
            
            solarData.forEach(point => {
                const color = getSolarColor(point.irradiance);
                const circle = L.circleMarker([point.lat, point.lng], {
                    radius: 8,
                    fillColor: color,
                    color: color,
                    weight: 2,
                    opacity: 0.8,
                    fillOpacity: 0.6
                });
                
                circle.bindPopup(`
                    <strong>Solar Irradiance</strong><br>
                    DNI: ${point.irradiance.dni} W/m²<br>
                    GHI: ${point.irradiance.ghi} W/m²<br>
                    DHI: ${point.irradiance.dhi} W/m²<br>
                    Coordinates: ${point.lat.toFixed(4)}, ${point.lng.toFixed(4)}
                `);
                
                solarLayer.addLayer(circle);
            });
            
            map.addLayer(solarLayer);
        }
        
        // Generate sample solar data
        function generateSampleSolarData() {
            const data = [];
            const center = [39.7392, -104.9903];
            const radius = 0.05;
            
            for (let i = 0; i < 100; i++) {
                const lat = center[0] + (Math.random() - 0.5) * radius;
                const lng = center[1] + (Math.random() - 0.5) * radius;
                
                data.push({
                    lat: lat,
                    lng: lng,
                    irradiance: {
                        dni: Math.floor(Math.random() * 400) + 600,
                        ghi: Math.floor(Math.random() * 300) + 400,
                        dhi: Math.floor(Math.random() * 150) + 100
                    }
                });
            }
            
            return data;
        }
        
        // Get color based on solar irradiance
        function getSolarColor(irradiance) {
            const dni = irradiance.dni;
            if (dni > 900) return '#ff4444';
            if (dni > 800) return '#ff8800';
            if (dni > 700) return '#ffaa00';
            if (dni > 600) return '#ffdd00';
            return '#88dd00';
        }
        
        // Initialize charts
        function initCharts() {
            // Production Chart
            const productionCtx = document.getElementById('productionChart');
            if (productionCtx) {
                productionChart = new Chart(productionCtx, {
                    type: 'line',
                    data: {
                        labels: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
                        datasets: [{
                            label: 'Monthly Production (MWh)',
                            data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                            borderColor: '#1e3c72',
                            backgroundColor: 'rgba(30, 60, 114, 0.1)',
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // Loss Chart
            const lossCtx = document.getElementById('lossChart');
            if (lossCtx) {
                lossChart = new Chart(lossCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Training Loss',
                            data: [],
                            borderColor: '#e74c3c',
                            backgroundColor: 'rgba(231, 76, 60, 0.1)'
                        }, {
                            label: 'Validation Loss',
                            data: [],
                            borderColor: '#3498db',
                            backgroundColor: 'rgba(52, 152, 219, 0.1)'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
        }
        
        // Tab switching functionality
        function switchTab(tabName) {
            // Remove active class from all tabs
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            // Add active class to selected tab
            event.target.classList.add('active');
            document.getElementById(tabName + '-tab').classList.add('active');
        }
        
        // NREL API functions
        async function fetchNRELData() {
            const apiKey = document.getElementById('nrelApiKey').value;
            const location = document.getElementById('location').value;
            
            if (!apiKey || !location) {
                showNotification('Please enter API key and location', 'error');
                return;
            }
            
            showLoading(true);
            logAPI(`Fetching NREL data for ${location}`, 'info');
            
            try {
                // Simulate API call with sample data
                await simulateAPICall(2000);
                
                const sampleData = {
                    location: location,
                    annual_ghi: 1650,
                    annual_dni: 2100,
                    annual_dhi: 850,
                    pvwatts_v1: {
                        ac_monthly: [120, 140, 180, 210, 240, 250, 245, 220, 190, 160, 130, 115],
                        ac_annual: 2200
                    }
                };
                
                updateNRELProgress(100);
                showNotification('NREL data fetched successfully', 'success');
                logAPI(`NREL data received: ${JSON.stringify(sampleData).substring(0, 100)}...`, 'success');
                
                // Update charts with new data
                if (productionChart) {
                    productionChart.data.datasets[0].data = sampleData.pvwatts_v1.ac_monthly;
                    productionChart.update();
                }
                
            } catch (error) {
                showNotification('Failed to fetch NREL data', 'error');
                logAPI(`NREL API error: ${error.message}`, 'error');
            } finally {
                showLoading(false);
            }
        }
        
        async function testNRELConnection() {
            logAPI('Testing NREL connection...', 'info');
            showLoading(true);
            
            try {
                await simulateAPICall(1000);
                updateStatusIndicator('nrelStatus', 'connected');
                showNotification('NREL connection successful', 'success');
                logAPI('NREL connection test passed', 'success');
            } catch (error) {
                updateStatusIndicator('nrelStatus', 'error');
                showNotification('NREL connection failed', 'error');
                logAPI('NREL connection test failed', 'error');
            } finally {
                showLoading(false);
            }
        }
        
        // NASA API functions
        async function fetchNASAData() {
            const lat = document.getElementById('nasaLat').value;
            const lon = document.getElementById('nasaLon').value;
            const dateRange = document.getElementById('dateRange').value;
            
            if (!lat || !lon) {
                showNotification('Please enter coordinates', 'error');
                return;
            }
            
            showLoading(true);
            logAPI(`Fetching NASA POWER data for ${lat}, ${lon}`, 'info');
            
            try {
                await simulateAPICall(1500);
                
                const sampleData = {
                    coordinates: { lat: parseFloat(lat), lon: parseFloat(lon) },
                    temperature: {
                        annual_avg: 12.5,
                        monthly: [2, 5, 10, 16, 22, 27, 30, 28, 23, 16, 8, 3]
                    },
                    solar_resource: {
                        dni: 2050,
                        ghi: 1620,
                        dhi: 870
                    }
                };
                
                showNotification('NASA data fetched successfully', 'success');
                logAPI(`NASA data received: ${JSON.stringify(sampleData).substring(0, 100)}...`, 'success');
                updateStatusIndicator('nasaStatus', 'connected');
                
            } catch (error) {
                showNotification('Failed to fetch NASA data', 'error');
                logAPI(`NASA API error: ${error.message}`, 'error');
                updateStatusIndicator('nasaStatus', 'error');
            } finally {
                showLoading(false);
            }
        }
        
        // File handling functions
        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const uploadDiv = document.getElementById('buildingUpload');
            uploadDiv.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                processFile(files[0]);
            }
        }
        
        function handleDragOver(e) {
            e.preventDefault();
            e.stopPropagation();
            document.getElementById('buildingUpload').classList.add('dragover');
        }
        
        function handleDragLeave(e) {
            e.preventDefault();
            e.stopPropagation();
            document.getElementById('buildingUpload').classList.remove('dragover');
        }
        
        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) {
                processFile(file);
            }
        }
        
        async function processFile(file) {
            showLoading(true);
            logAPI(`Processing file: ${file.name}`, 'info');
            
            try {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        loadBuildingFootprints(data);
                        showNotification('Building data loaded successfully', 'success');
                        logAPI(`File processed: ${file.name}`, 'success');
                    } catch (error) {
                        showNotification('Invalid file format', 'error');
                        logAPI(`File processing error: ${error.message}`, 'error');
                    } finally {
                        showLoading(false);
                    }
                };
                reader.readAsText(file);
            } catch (error) {
                showNotification('File processing failed', 'error');
                logAPI(`File error: ${error.message}`, 'error');
                showLoading(false);
            }
        }
        
        function loadBuildingFootprints(geoJsonData) {
            if (buildingLayer) {
                map.removeLayer(buildingLayer);
            }
            
            buildingLayer = L.geoJSON(geoJsonData, {
                style: {
                    color: '#ff7800',
                    weight: 2,
                    opacity: 0.8,
                    fillOpacity: 0.3
                },
                onEachFeature: function(feature, layer) {
                    if (feature.properties) {
                        let popupContent = '<strong>Building Properties</strong><br>';
                        for (let key in feature.properties) {
                            popupContent += `${key}: ${feature.properties[key]}<br>`;
                        }
                        layer.bindPopup(popupContent);
                    }
                }
            });
            
            // Auto-enable building layer checkbox
            document.getElementById('buildingLayer').checked = true;
            map.addLayer(buildingLayer);
        }
        
        // DEM data loading
        async function loadDEMData() {
            const source = document.getElementById('demSource').value;
            showLoading(true);
            logAPI(`Loading DEM data from ${source}`, 'info');
            
            try {
                await simulateAPICall(2000);
                
                // Generate synthetic elevation data
                const elevationData = generateSyntheticDEM();
                createDEMLayer(elevationData);
                
                showNotification('Elevation data loaded', 'success');
                logAPI('DEM data loaded successfully', 'success');
            } catch (error) {
                showNotification('Failed to load elevation data', 'error');
                logAPI(`DEM loading error: ${error.message}`, 'error');
            } finally {
                showLoading(false);
            }
        }
        
        function generateSyntheticDEM() {
            const data = [];
            const bounds = map.getBounds();
            const step = 0.005;
            
            for (let lat = bounds.getSouth(); lat <= bounds.getNorth(); lat += step) {
                for (let lng = bounds.getWest(); lng <= bounds.getEast(); lng += step) {
                    const elevation = Math.floor(Math.random() * 200) + 1500; // 1500-1700m elevation
                    data.push({ lat, lng, elevation });
                }
            }
            
            return data;
        }
        
        function createDEMLayer(elevationData) {
            if (demLayer) {
                map.removeLayer(demLayer);
            }
            
            demLayer = L.layerGroup();
            
            elevationData.forEach(point => {
                const color = getElevationColor(point.elevation);
                const circle = L.circleMarker([point.lat, point.lng], {
                    radius: 3,
                    fillColor: color,
                    color: color,
                    weight: 1,
                    opacity: 0.6,
                    fillOpacity: 0.4
                });
                
                circle.bindPopup(`Elevation: ${point.elevation}m`);
                demLayer.addLayer(circle);
            });
        }
        
        function getElevationColor(elevation) {
            if (elevation > 1650) return '#8B4513';
            if (elevation > 1600) return '#A0522D';
            if (elevation > 1550) return '#CD853F';
            if (elevation > 1500) return '#DEB887';
            return '#F5DEB3';
        }
        
        // Solar analysis functions
        async function runAdvancedAnalysis() {
            const params = {
                panelType: document.getElementById('panelType').value,
                tiltAngle: parseFloat(document.getElementById('tiltAngle').value),
                azimuth: parseFloat(document.getElementById('azimuth').value),
                systemLosses: parseFloat(document.getElementById('systemLosses').value)
            };
            
            showLoading(true);
            logAPI('Running advanced solar analysis...', 'info');
            
            try {
                await simulateAPICall(3000);
                
                const results = calculateSolarMetrics(params);
                updateAnalysisResults(results);
                
                showNotification('Analysis completed successfully', 'success');
                logAPI(`Analysis results: ${JSON.stringify(results)}`, 'success');
            } catch (error) {
                showNotification('Analysis failed', 'error');
                logAPI(`Analysis error: ${error.message}`, 'error');
            } finally {
                showLoading(false);
            }
        }
        
        function calculateSolarMetrics(params) {
            // Solar calculations based on parameters
            const baseProduction = 1000; // Base kWh per installed kW
            const efficiencyMultipliers = {
                mono: 1.0,
                poly: 0.85,
                thin: 0.55,
                bifacial: 1.1
            };
            
            const tiltMultiplier = Math.cos((params.tiltAngle - 35) * Math.PI / 180) * 0.95 + 0.05;
            const azimuthMultiplier = Math.cos((params.azimuth - 180) * Math.PI / 180) * 0.1 + 0.9;
            const lossMultiplier = (100 - params.systemLosses) / 100;
            
            const annualProduction = baseProduction * 
                efficiencyMultipliers[params.panelType] * 
                tiltMultiplier * 
                azimuthMultiplier * 
                lossMultiplier;
            
            const capacityFactor = (annualProduction / (365 * 24)) * 100;
            const lcoe = 0.05 + (1 - efficiencyMultipliers[params.panelType]) * 0.02;
            const payback = 8 / efficiencyMultipliers[params.panelType];
            
            return {
                annualProduction: Math.round(annualProduction),
                capacityFactor: Math.round(capacityFactor * 10) / 10,
                lcoe: Math.round(lcoe * 1000) / 1000,
                payback: Math.round(payback * 10) / 10
            };
        }
        
        function updateAnalysisResults(results) {
            document.getElementById('annualProduction').textContent = `${results.annualProduction} kWh`;
            document.getElementById('capacityFactor').textContent = `${results.capacityFactor}%`;
            document.getElementById('lcoe').textContent = `${results.lcoe}/kWh`;
            document.getElementById('payback').textContent = `${results.payback} years`;
        }
        
        async function optimizeParameters() {
            showLoading(true);
            logAPI('Optimizing solar parameters...', 'info');
            
            try {
                await simulateAPICall(2000);
                
                // Optimize for maximum production
                const optimalParams = {
                    tilt: 35, // Latitude-based optimization
                    azimuth: 180, // South-facing
                    panelType: 'bifacial'
                };
                
                document.getElementById('tiltAngle').value = optimalParams.tilt;
                document.getElementById('azimuth').value = optimalParams.azimuth;
                document.getElementById('panelType').value = optimalParams.panelType;
                
                showNotification('Parameters optimized successfully', 'success');
                logAPI(`Optimized parameters: ${JSON.stringify(optimalParams)}`, 'success');
                
                // Run analysis with optimized parameters
                await runAdvancedAnalysis();
            } catch (error) {
                showNotification('Optimization failed', 'error');
                logAPI(`Optimization error: ${error.message}`, 'error');
            } finally {
                showLoading(false);
            }
        }
        
        // AI Model functions
        async function trainModel() {
            if (isTraining) {
                showNotification('Model is already training', 'warning');
                return;
            }
            
            isTraining = true;
            const trainBtn = document.getElementById('trainBtn');
            trainBtn.textContent = 'Training...';
            trainBtn.disabled = true;
            
            logAPI('Starting model training...', 'info');
            updateStatusIndicator('modelStatus', 'training');
            
            try {
                // Generate training data
                const data = generateTrainingData();
                
                // Create and train model
                model = await createTensorFlowModel();
                
                // Simulate training process
                for (let epoch = 1; epoch <= 10; epoch++) {
                    await simulateAPICall(500);
                    
                    const loss = 0.5 * Math.exp(-epoch * 0.3) + Math.random() * 0.1;
                    const valLoss = loss + Math.random() * 0.05;
                    const accuracy = (1 - loss) * 100;
                    const valR2 = Math.min(0.95, 0.5 + epoch * 0.05 + Math.random() * 0.1);
                    
                    updateTrainingProgress(epoch, 10, loss, accuracy, valR2);
                    updateLossChart(epoch, loss, valLoss);
                }
                
                showNotification('Model training completed', 'success');
                logAPI('Model training completed successfully', 'success');
                updateStatusIndicator('modelStatus', 'connected');
                
            } catch (error) {
                showNotification('Model training failed', 'error');
                logAPI(`Training error: ${error.message}`, 'error');
                updateStatusIndicator('modelStatus', 'error');
            } finally {
                isTraining = false;
                trainBtn.textContent = 'Start Training';
                trainBtn.disabled = false;
            }
        }
        
        async function createTensorFlowModel() {
            // Create a simple neural network model
            const model = tf.sequential({
                layers: [
                    tf.layers.dense({ inputShape: [11], units: 64, activation: 'relu' }),
                    tf.layers.dropout({ rate: 0.2 }),
                    tf.layers.dense({ units: 32, activation: 'relu' }),
                    tf.layers.dropout({ rate: 0.2 }),
                    tf.layers.dense({ units: 16, activation: 'relu' }),
                    tf.layers.dense({ units: 1, activation: 'linear' })
                ]
            });
            
            model.compile({
                optimizer: 'adam',
                loss: 'meanSquaredError',
                metrics: ['mae']
            });
            
            return model;
        }
        
        function generateTrainingData() {
            const data = [];
            for (let i = 0; i < 1000; i++) {
                data.push({
                    features: [
                        Math.random() * 90 - 45, // latitude
                        Math.random() * 360 - 180, // longitude
                        Math.random() * 500 + 50, // roof_area
                        Math.random() * 360, // azimuth
                        Math.random() * 90, // tilt
                        Math.random(), // shading_factor
                        Math.random() * 0.25 + 0.15, // panel_efficiency
                        Math.random() * 40 + 10, // temperature
                        Math.random() * 800 + 200, // dni
                        Math.random() * 600 + 100, // ghi
                        Math.random() * 300 + 50 // dhi
                    ],
                    target: Math.random() * 2000 + 500 // energy output
                });
            }
            return data;
        }
        
        function updateTrainingProgress(epoch, totalEpochs, loss, accuracy, valR2) {
            document.getElementById('currentEpoch').textContent = `${epoch}/${totalEpochs}`;
            document.getElementById('trainingLoss').textContent = loss.toFixed(4);
            document.getElementById('modelAccuracy').textContent = `${accuracy.toFixed(1)}%`;
            document.getElementById('valR2').textContent = valR2.toFixed(3);
        }
        
        function updateLossChart(epoch, loss, valLoss) {
            if (!lossChart) return;
            
            lossChart.data.labels.push(epoch);
            lossChart.data.datasets[0].data.push(loss);
            lossChart.data.datasets[1].data.push(valLoss);
            lossChart.update();
        }
        
        async function loadPretrainedModel() {
            showLoading(true);
            logAPI('Loading pretrained model...', 'info');
            
            try {
                await simulateAPICall(1500);
                
                model = await createTensorFlowModel();
                
                // Simulate loading pretrained weights
                updateTrainingProgress(100, 100, 0.045, 92.5, 0.89);
                
                showNotification('Pretrained model loaded', 'success');
                logAPI('Pretrained model loaded successfully', 'success');
                updateStatusIndicator('modelStatus', 'connected');
            } catch (error) {
                showNotification('Failed to load pretrained model', 'error');
                logAPI(`Model loading error: ${error.message}`, 'error');
            } finally {
                showLoading(false);
            }
        }
        
        async function makePrediction() {
            if (!model) {
                showNotification('Please train or load a model first', 'warning');
                return;
            }
            
            try {
                const input = JSON.parse(document.getElementById('testInput').value);
                
                // Convert input to tensor
                const features = [
                    input.latitude || 39.7392,
                    input.longitude || -104.9903,
                    input.roof_area || 200,
                    input.azimuth || 180,
                    input.tilt || 35,
                    input.shading_factor || 0.1,
                    input.panel_efficiency || 0.20,
                    input.temperature || 25,
                    input.dni || 800,
                    input.ghi || 500,
                    input.dhi || 150
                ];
                
                // Simulate prediction
                const prediction = Math.random() * 1500 + 800;
                
                const result = `
                    <h4>🔮 Prediction Results</h4>
                    <div class="metric-grid">
                        <div class="metric-item">
                            <div class="metric-label">Predicted Output</div>
                            <div class="metric-value">${Math.round(prediction)} kWh/year</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-label">Confidence</div>
                            <div class="metric-value">${Math.round(Math.random() * 15 + 80)}%</div>
                        </div>
                    </div>
                    <p style="margin-top: 10px; color: #666; font-size: 0.9em;">
                        Based on the provided parameters and current model training.
                    </p>
                `;
                
                document.getElementById('predictionResult').innerHTML = result;
                
                showNotification('Prediction completed', 'success');
                logAPI(`Prediction made: ${Math.round(prediction)} kWh/year`, 'success');
                
            } catch (error) {
                showNotification('Invalid input format', 'error');
                logAPI(`Prediction error: ${error.message}`, 'error');
            }
        }
        
        // Layer toggle functions
        function toggleLayer(layerType) {
            const checkbox = document.getElementById(layerType + 'Layer');
            
            switch(layerType) {
                case 'solar':
                    if (checkbox.checked && solarLayer) {
                        map.addLayer(solarLayer);
                    } else if (solarLayer) {
                        map.removeLayer(solarLayer);
                    }
                    break;
                    
                case 'buildings':
                    if (checkbox.checked && buildingLayer) {
                        map.addLayer(buildingLayer);
                    } else if (buildingLayer) {
                        map.removeLayer(buildingLayer);
                    }
                    break;
                    
                case 'shadows':
                    if (checkbox.checked) {
                        showShadowPanel(true);
                        calculateShadows();
                    } else {
                        showShadowPanel(false);
                        if (shadowLayer) {
                            map.removeLayer(shadowLayer);
                        }
                    }
                    break;
                    
                case 'dem':
                    if (checkbox.checked && demLayer) {
                        map.addLayer(demLayer);
                    } else if (demLayer) {
                        map.removeLayer(demLayer);
                    }
                    break;
            }
        }
        
        // Shadow analysis functions
        function showShadowPanel(show) {
            const panel = document.getElementById('shadowPanel');
            panel.style.display = show ? 'block' : 'none';
        }
        
        function updateShadowAnalysis() {
            if (document.getElementById('shadowLayer').checked) {
                calculateShadows();
            }
        }
        
        function calculateShadows() {
            const date = document.getElementById('shadowDate').value;
            const time = document.getElementById('shadowTime').value;
            const buildingHeight = parseFloat(document.getElementById('buildingHeight').value);
            
            logAPI(`Calculating shadows for ${date} at ${time}`, 'info');
            
            if (shadowLayer) {
                map.removeLayer(shadowLayer);
            }
            
            shadowLayer = L.layerGroup();
            
            // Generate sample shadow polygons
            const shadows = generateShadowData(buildingHeight, date, time);
            
            shadows.forEach(shadow => {
                const polygon = L.polygon(shadow.coordinates, {
                    color: '#000080',
                    fillColor: '#000080',
                    fillOpacity: 0.3,
                    weight: 2
                });
                
                polygon.bindPopup(`
                    <strong>Shadow Analysis</strong><br>
                    Building Height: ${buildingHeight}m<br>
                    Shadow Length: ${shadow.length}m<br>
                    Time: ${time}<br>
                    Date: ${date}
                `);
                
                shadowLayer.addLayer(polygon);
            });
            
            map.addLayer(shadowLayer);
            showNotification('Shadow analysis updated', 'success');
        }
        
        function generateShadowData(height, date, time) {
            const shadows = [];
            const center = map.getCenter();
            
            // Calculate sun angle based on date and time
            const sunAngle = calculateSunAngle(date, time, center.lat);
            const shadowLength = height / Math.tan(sunAngle * Math.PI / 180);
            
            // Generate sample shadow polygons
            for (let i = 0; i < 5; i++) {
                const buildingLat = center.lat + (Math.random() - 0.5) * 0.01;
                const buildingLng = center.lng + (Math.random() - 0.5) * 0.01;
                
                const shadowEndLat = buildingLat + (shadowLength / 111000) * Math.cos(180 * Math.PI / 180);
                const shadowEndLng = buildingLng + (shadowLength / (111000 * Math.cos(buildingLat * Math.PI / 180))) * Math.sin(180 * Math.PI / 180);
                
                shadows.push({
                    coordinates: [
                        [buildingLat, buildingLng],
                        [buildingLat + 0.0001, buildingLng],
                        [shadowEndLat + 0.0001, shadowEndLng],
                        [shadowEndLat, shadowEndLng]
                    ],
                    length: Math.round(shadowLength)
                });
            }
            
            return shadows;
        }
        
        function calculateSunAngle(date, time, latitude) {
            // Simplified sun angle calculation
            const dayOfYear = new Date(date).getDayOfYear();
            const hour = parseInt(time.split(':')[0]);
            const minute = parseInt(time.split(':')[1]);
            const timeDecimal = hour + minute / 60;
            
            const declination = 23.45 * Math.sin((360 * (284 + dayOfYear) / 365) * Math.PI / 180);
            const hourAngle = 15 * (timeDecimal - 12);
            
            const elevation = Math.asin(
                Math.sin(declination * Math.PI / 180) * Math.sin(latitude * Math.PI / 180) +
                Math.cos(declination * Math.PI / 180) * Math.cos(latitude * Math.PI / 180) * Math.cos(hourAngle * Math.PI / 180)
            ) * 180 / Math.PI;
            
            return Math.max(5, elevation); // Minimum 5 degrees
        }
        
        // Drawing and measurement tools
        function startDrawing() {
            showNotification('Drawing mode activated - click on map to draw', 'info');
        }
        
        function measureDistance() {
            showNotification('Distance tool activated - click two points to measure', 'info');
            let clickCount = 0;
            let firstPoint = null;
            
            const measureHandler = function(e) {
                clickCount++;
                
                if (clickCount === 1) {
                    firstPoint = e.latlng;
                    L.marker(firstPoint).addTo(drawnItems);
                } else if (clickCount === 2) {
                    const secondPoint = e.latlng;
                    L.marker(secondPoint).addTo(drawnItems);
                    
                    const distance = firstPoint.distanceTo(secondPoint);
                    const line = L.polyline([firstPoint, secondPoint], {color: 'red'}).addTo(drawnItems);
                    
                    line.bindPopup(`Distance: ${Math.round(distance)}m`).openPopup();
                    
                    map.off('click', measureHandler);
                    showNotification(`Distance measured: ${Math.round(distance)}m`, 'success');
                }
            };
            
            map.on('click', measureHandler);
        }
        
        function clearDrawings() {
            drawnItems.clearLayers();
            showNotification('Drawings cleared', 'info');
        }
        
        // Area analysis
        function calculateAreaAnalysis(layer) {
            if (!layer.getLatLngs) return;
            
            const latlngs = layer.getLatLngs()[0];
            const area = turf.area(turf.polygon([latlngs.map(ll => [ll.lng, ll.lat])]));
            
            // Estimate solar potential
            const avgIrradiance = 1650; // kWh/m²/year
            const systemEfficiency = 0.85;
            const panelEfficiency = 0.20;
            const roofUsableFactor = 0.75;
            
            const usableArea = area * roofUsableFactor;
            const annualProduction = usableArea * avgIrradiance * systemEfficiency * panelEfficiency / 1000; // MWh
            
            layer.bindPopup(`
                <strong>Area Analysis</strong><br>
                Total Area: ${Math.round(area)}m²<br>
                Usable Area: ${Math.round(usableArea)}m²<br>
                Est. Annual Production: ${Math.round(annualProduction * 10) / 10} MWh<br>
                Est. System Size: ${Math.round(usableArea * panelEfficiency / 1000 * 10) / 10} MW
            `).openPopup();
        }
        
        // API functions
        function generateAPIKey() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let result = 'sk-';
            for (let i = 0; i < 32; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            document.getElementById('apiKey').value = result;
            showNotification('New API key generated', 'success');
        }
        
        function saveAPIConfig() {
            const config = {
                apiKey: document.getElementById('apiKey').value,
                rateLimit: document.getElementById('rateLimit').value,
                webhookUrl: document.getElementById('webhookUrl').value
            };
            
            logAPI(`API configuration saved: ${JSON.stringify(config)}`, 'success');
            showNotification('API configuration saved', 'success');
        }
        
        async function testAPI() {
            const endpoint = document.getElementById('testEndpoint').value;
            const requestBody = document.getElementById('requestBody').value;
            
            showLoading(true);
            logAPI(`Testing API endpoint: ${endpoint}`, 'info');
            
            try {
                await simulateAPICall(1000);
                
                const mockResponse = {
                    status: 'success',
                    data: {
                        endpoint: endpoint,
                        timestamp: new Date().toISOString(),
                        result: endpoint.includes('predict') ? 
                            { prediction: Math.round(Math.random() * 2000 + 800), confidence: 0.92 } :
                            { solar_potential: Math.round(Math.random() * 1500 + 1000), location: 'Denver, CO' }
                    },
                    execution_time: '245ms'
                };
                
                document.getElementById('apiResponse').textContent = JSON.stringify(mockResponse, null, 2);
                showNotification('API test successful', 'success');
                logAPI(`API test completed: ${endpoint}`, 'success');
                
            } catch (error) {
                document.getElementById('apiResponse').textContent = `Error: ${error.message}`;
                showNotification('API test failed', 'error');
                logAPI(`API test failed: ${error.message}`, 'error');
            } finally {
                showLoading(false);
            }
        }
        
        // Utility functions
        function showLoading(show) {
            const spinner = document.getElementById('loadingSpinner');
            spinner.style.display = show ? 'flex' : 'none';
        }
        
        function showNotification(message, type) {
            const notification = document.createElement('div');
            notification.className = `notification ${type} show`;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
        }
        
        function logAPI(message, type) {
            const timestamp = new Date().toLocaleTimeString();
            const log = document.createElement('div');
            log.className = 'api-log';
            log.innerHTML = `<span style="color: ${type === 'success' ? '#4caf50' : type === 'error' ? '#f44336' : '#2196f3'}">[${timestamp}]</span> ${message}`;
            
            const logsContainer = document.getElementById('apiLogs');
            logsContainer.appendChild(log);
            logsContainer.scrollTop = logsContainer.scrollHeight;
            
            // Keep only last 20 logs
            while (logsContainer.children.length > 20) {
                logsContainer.removeChild(logsContainer.firstChild);
            }
        }
        
        function updateNRELProgress(percent) {
            document.getElementById('nrelProgress').style.width = percent + '%';
        }
        
        function updateStatusIndicator(elementId, status) {
            const indicator = document.getElementById(elementId);
            indicator.style.background = status === 'connected' ? '#4caf50' : 
                                       status === 'error' ? '#f44336' : 
                                       status === 'training' ? '#ff9800' : '#666';
        }
        
        function updateStatusIndicators() {
            updateStatusIndicator('nrelStatus', 'connected');
            updateStatusIndicator('nasaStatus', 'connected');
            updateStatusIndicator('modelStatus', 'connected');
        }
        
        function updateCoordinateInputs(lat, lng) {
            document.getElementById('nasaLat').value = lat.toFixed(4);
            document.getElementById('nasaLon').value = lng.toFixed(4);
        }
        
        function showLocationPopup(latlng, lat, lng) {
            const popup = L.popup()
                .setLatLng(latlng)
                .setContent(`
                    <strong>Location Info</strong><br>
                    Lat: ${lat.toFixed(4)}<br>
                    Lng: ${lng.toFixed(4)}<br>
                    <button onclick="fetchLocationData(${lat}, ${lng})" class="btn" style="margin-top: 10px;">
                        Analyze Solar Potential
                    </button>
                `)
                .openOn(map);
        }
        
        async function fetchLocationData(lat, lng) {
            showLoading(true);
            logAPI(`Fetching location data for ${lat}, ${lng}`, 'info');
            
            try {
                await simulateAPICall(1500);
                
                const locationData = {
                    coordinates: { lat, lng },
                    solar_resource: {
                        dni: Math.floor(Math.random() * 400) + 600,
                        ghi: Math.floor(Math.random() * 300) + 400,
                        temperature: Math.floor(Math.random() * 20) + 15
                    },
                    estimated_annual_production: Math.floor(Math.random() * 500) + 800
                };
                
                showNotification(`Solar potential: ${locationData.estimated_annual_production} kWh/kW`, 'success');
                logAPI(`Location data: ${JSON.stringify(locationData)}`, 'success');
                
                // Update inputs with clicked coordinates
                updateCoordinateInputs(lat, lng);
                
            } catch (error) {
                showNotification('Failed to fetch location data', 'error');
                logAPI(`Location data error: ${error.message}`, 'error');
            } finally {
                showLoading(false);
            }
        }
        
        function loadSampleData() {
            // Load some sample building footprints
            const sampleGeoJSON = {
                "type": "FeatureCollection",
                "features": [
                    {
                        "type": "Feature",
                        "properties": {
                            "name": "Sample Building 1",
                            "area": 2500,
                            "height": 15
                        },
                        "geometry": {
                            "type": "Polygon",
                            "coordinates": [[
                                [-104.9903, 39.7392],
                                [-104.9893, 39.7392],
                                [-104.9893, 39.7382],
                                [-104.9903, 39.7382],
                                [-104.9903, 39.7392]
                            ]]
                        }
                    },
                    {
                        "type": "Feature",
                        "properties": {
                            "name": "Sample Building 2",
                            "area": 1800,
                            "height": 12
                        },
                        "geometry": {
                            "type": "Polygon",
                            "coordinates": [[
                                [-104.9873, 39.7402],
                                [-104.9863, 39.7402],
                                [-104.9863, 39.7397],
                                [-104.9873, 39.7397],
                                [-104.9873, 39.7402]
                            ]]
                        }
                    }
                ]
            };
            
            loadBuildingFootprints(sampleGeoJSON);
            logAPI('Sample building data loaded', 'success');
        }
        
        function simulateAPICall(duration) {
            return new Promise(resolve => setTimeout(resolve, duration));
        }
        
        // Date extension for day of year calculation
        Date.prototype.getDayOfYear = function() {
            const start = new Date(this.getFullYear(), 0, 0);
            const diff = this - start;
            const oneDay = 1000 * 60 * 60 * 24;
            return Math.floor(diff / oneDay);
        };
        
        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case '1':
                        e.preventDefault();
                        document.querySelector('[onclick="switchTab(\'data\')"]').click();
                        break;
                    case '2':
                        e.preventDefault();
                        document.querySelector('[onclick="switchTab(\'analysis\')"]').click();
                        break;
                    case '3':
                        e.preventDefault();
                        document.querySelector('[onclick="switchTab(\'model\')"]').click();
                        break;
                    case '4':
                        e.preventDefault();
                        document.querySelector('[onclick="switchTab(\'api\')"]').click();
                        break;
                    case 'Enter':
                        e.preventDefault();
                        const activeTab = document.querySelector('.tab-content.active');
                        if (activeTab.id === 'analysis-tab') {
                            runAdvancedAnalysis();
                        } else if (activeTab.id === 'model-tab') {
                            trainModel();
                        }
                        break;
                }
            }
        });
        
        // Auto-save functionality for inputs
        function setupAutoSave() {
            const inputs = document.querySelectorAll('input, select, textarea');
            inputs.forEach(input => {
                input.addEventListener('change', function() {
                    const data = {};
                    data[this.id] = this.value;
                    // In a real app, this would save to localStorage or send to server
                    console.log('Auto-saved:', data);
                });
            });
        }
        
        // Initialize auto-save after DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            setupAutoSave();
        });
        
        // Export functionality
        function exportResults() {
            const results = {
                timestamp: new Date().toISOString(),
                analysis: currentAnalysis,
                coordinates: {
                    lat: document.getElementById('nasaLat').value,
                    lng: document.getElementById('nasaLon').value
                },
                parameters: {
                    panelType: document.getElementById('panelType').value,
                    tiltAngle: document.getElementById('tiltAngle').value,
                    azimuth: document.getElementById('azimuth').value,
                    systemLosses: document.getElementById('systemLosses').value
                }
            };
            
            const dataStr = JSON.stringify(results, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            
            const exportFileDefaultName = `solar_analysis_${new Date().toISOString().split('T')[0]}.json`;
            
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileDefaultName);
            linkElement.click();
            
            showNotification('Analysis results exported', 'success');
        }
        
        // Add export button to analysis results
        document.addEventListener('DOMContentLoaded', function() {
            const resultsPanel = document.querySelector('#analysis-tab .results-panel');
            if (resultsPanel) {
                const exportBtn = document.createElement('button');
                exportBtn.className = 'btn btn-secondary';
                exportBtn.textContent = '📥 Export Results';
                exportBtn.onclick = exportResults;
                resultsPanel.appendChild(exportBtn);
            }
        });
    </script>
</body>
</html>
                    
                